"""
Алгоритм локального выравнивания последовательностей используется для определения сходных участков между двумя цепочками последовательностей нуклеиновых кислот или последовательностей белка
Алгоритм сравнивает сегменты всех возможных длин и оптимизирует меру сходства.
"""

import itertools   # используем для получения всех упорядоченных пар двух множеств (декартово произведение)
import numpy as np  # используем, так как модуль поддерживает много полезных структур данных и значительно упрощает код


"""
Сначала вычислим матрицу оценок между двумя последовательностями
В зависимости от того, совпадают ли элементы последовательностей или нет - будем присваивать элементу матрицы значение (match_= 3 - совпало, gap_= 2 - не совпало)
(В коде +1 и -1 от того, что нумерация начинается с нуля)
"""
def matrix(a, b, match_, gap_):
    H = np.zeros((len(a) + 1, len(b) + 1), np.int64)      # изначально заполним матрицу нулями - так будет легче  потом получить окончательную последовательность
    for i, j in itertools.product(range(1, H.shape[0]), range(1, H.shape[1])):    # декартово умножим столбцы и рядки - получим массив из кортежей вида (a,b), где каждый элемент - это соотвествующий элемент матрицы 
        match = H[i - 1, j - 1] + (match_ if a[i - 1] == b[j - 1] else - match_) 
        delete = H[i - 1, j] - gap_
        insert = H[i, j - 1] - gap_
        H[i, j] = max(match, delete, insert, 0)   # элемент матрицы заполняем в зависимости от 1) схождения 2) не схождения 3) промежутка несходящихся элементов
    return H



"""
Затем, имея матрицу оценок, можем перейти к вычислению максимального общего участка (учитывая промежутки) используя рекурсию для 
"""
def back_func(H, b, b_='', old_i=0):
    H_flip = np.flip(np.flip(H, 0), 1)   # "перевернем" матрицу, чтобы алгоритм был эффективнее
    i_, j_ = np.unravel_index(H_flip.argmax(), H_flip.shape)
    i, j = np.subtract(H.shape, (i_ + 1, j_ + 1))  # (i, j) -  последние элементы матрицы
    if H[i, j] == 0:
        return b_, j
    b_ = b[j - 1] + '-' + b_ if old_i - i > 1 else b[j - 1] + b_       # "-" для не совпадающего промежутка
    return back_func(H[0:i, 0:j], b, b_, i)                         # рекурсивно запускаем функцию для матрицы меньшего размера , учитывая
    

"""
Собственно, реализуем алгоритм 
match_ и gap_ выбираем произвольно ( match < gap !) ,  выбранные данные из классического алгоритма 
"""

def alg(a, b, match_=5, gap_=3):
    H = matrix(a, b, match_, gap_)  
    b_, pos = back_func(H, b)
    return pos, pos + len(b_)


a, b = 'GTTFGACTA', 'GAGTACGG'
start, end = alg(a, b)
print(f'a = {a}  b = {b}  \nresult = ' , a[start:end])

